-- Here are some standard definitions that hopefully do not compute too much.
-- QUESTION: surely we wanna make the Bristol Prelude consist of different modules
--           that follow the grouping of the book, or another logical grouping?

{- | Identity function. -}
\func id {A : \Type} (x : A) : A => x

{- | Identity path formation.
 -
 - (Wrapper around the Arend prelude {idp} to match HoTT book naming.)
 -
 - QUESTION: what is happening?
 -  -}
\func refl {A : \Type} {a : A} : a = a => idp

{- | Path induction.
 -
 - Induction principle for paths: takes proof of a property (that takes the form
 - of the type class C) at refl and extrapolates that this property / type class
 - holds for all paths.
 -
 - -}
\func J {A : \Type}                              -- Base space of property.
        (C : \Pi (x y : A) (p : x = y) -> \Type) -- Property to prove.
        (f : \Pi (x : A) -> C x x idp)           -- Proof at refl.
        -- Way of constructing proof of property for any path.
        (x y : A)   -- End points of path in question.
        (p : x = y) -- Path.
        : C x y p   -- Proof of property on path / application of type fam.
  \elim p
    | idp => f(x) -- QUESTION: I don't like how shit is going on under the hood,
                  -- and how the Arend prelude says this is wrong.

{- | Transportation.
 -
 - Transports a path from base space A through a type fam to create a path in the
 - total space of that type fam.
 -
 - -}
\func transport {A : \Type}      -- Base space.
                (B : A -> \Type) -- Type fam to transport along.
                {x y : A}        -- Points at end points of path in base space.
                (p : x = y)      -- Path to transport.
                : B x -> B y     -- Transported path. (Lives in total space)
  => J (\lam x y p => B x -> B y) (\lam x => id) x y p
  -- Implemented via the induction principle on paths.
  -- i.e. we just show for refl,
  -- then we get the whole bifta,
  -- which we can apply to our path :D

-- -----------------------------------------------------------------------------
-- FUNCTOR
-- -----------------------------------------------------------------------------

{- | Translates a path between spaces along a function f : A -> B.
-
- This function encapsulates how functions behave functorially on paths
- i.e. how paths are preserved by functions between spaces, and thus you can translate
-      a path in one space to another
- -}
\func ap {A B : \Type} (f : A -> B) {x y : A} (p : x = y) : f x = f y
  \elim p
    | idp => idp
    -- Use path induction to pattern match on the refl case, where path translation is trivial.

-- Functor laws:
-- Just read {ap f} as {fmap f}
{- | Identity functor law .-}
\func ap_id {A B : \Type} (f : A -> B) {x : A} : ap f {x} {x} idp = idp
  => idp
{- | Composition functor law .-}
\func ap_compose {A B : \Type} (f : A -> B) {x y z : A} (p : x = y) (q : y = z)
  : ap f (p *> q) = ap f p *> ap f q
\elim q
  | idp => idp

\func ap_inv {A B : \Type} (f : A -> B) {x y : A} (p : x = y)
  : ap f (p `inv) = (ap f p) `inv
\elim p
  | idp => idp

-- -----------------------------------------------------------------------------
-- GROUPOID
-- -----------------------------------------------------------------------------

-- Groupoid structure.
-- i.e how paths form the morphisms of a category where every morphism is invertable.
{- | Identity Path .-}
\func \fix 2 qed {A : \Type} (a : A) : a = a => idp
{- | Path Composition .-}
-- QUESTION: why are there two?
\func \infixr 9 *> {A : \Type} {x y z : A} (p : x = y) (q : y = z) : x = z
  \elim q
    | idp => p
\func \infixr 9 <* {A : \Type} {x y z : A} (p : x = y) (q : y = z) : x = z
  \elim p
    | idp => q
{- | Path Inversion .-}
\func \fix 10 inv {A : \Type} {a a' : A} (p : a = a') : a' = a
  \elim p
    | idp => idp

-- Standard groupoid laws.
-- Composing with id does nothing
\func idp_*> {A : \Type} {x y : A} (p : x = y) : idp *> p = p
  \elim p
    | idp => idp
\func *>_idp {A : \Type} {x y : A} (p : x = y) : p *> idp = p
  => idp
-- Composing with inversion is same as id
\func *>_inv {A : \Type} {x y : A} (p : x = y) : p *> p `inv = idp
  \elim p
    | idp => idp
\func inv_*> {A : \Type} {x y : A} (p : x = y) : p `inv *> p = idp
  \elim p
    | idp => idp
